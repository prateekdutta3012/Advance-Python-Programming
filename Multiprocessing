How to create and start multiple processes
How to wait for processes to complete
How to share data between processes
How to use Locks to prevent race conditions
How to use a Queue for process-safe data/task processing.
How to use a Pool to manage multiple worker processes
Create and run processes
You create a process with multiprocessing.Process(). It takes two important arguments:

target: a callable object (function) for this process to be invoked when the process starts
args: the (function) arguments for the target function. This must be a tuple
Start a process with process.start()

Call process.join() to tell the program that it should wait for this process to complete before it continues with the rest of the code.

Share data between processes
Since processes don't live in the same memory space, they do not have access to the same (public) data. Thus, they need special shared memory objects to share data.

Data can be stored in a shared memory variable using Value or Array.

Value(type, value): Create a ctypes object of type type. Access the value with .target.
Array(type, value): Create a ctypes array with elements of type type. Access the values with [].
Task: Create two processes, each process should have access to a shared variable and modify it (in this case only increase it repeatedly by 1 for 100 times). Create 
another two processes that share an array and modify (increase) all the elements in the array.

Race condition
A race condition happened here. A race condition occurs when two or more processes or threads can access shared data and they try to change it at the same time. In our
example the two processes have to read the shared value, increase it by 1, and write it back into the shared variable. If this happens at the same time, the two 
processes read the same value, increase it and write it back. Thus, both processes write the same increased value back into the shared object. 

Avoid race conditions with Locks
A lock (also known as mutex) is a synchronization mechanism for enforcing limits on access to a resource in an environment where there are many processes/threads of 
execution. A Lock has two states: locked and unlocked. If the state is locked, it does not allow other concurrent processes/threads to enter this code section until 
the state is unlocked again.

Two functions are important:

lock.acquire() : This will lock the state and block
lock.release() : This will unlock the state again.


